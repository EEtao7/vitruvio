% main

clear all
close all

%% select task and robot to be loaded
taskSelection = 'universalStairs';
robotSelection = 'universal';
fprintf('loading data for %s \n', taskSelection);

%% get suggested removal ratio for cropping motion data to useful steady state motion

[removalRatioStart, removalRatioEnd] = getSuggestedRemovalRatios(taskSelection);

%% load motion and force data
% universalTrot
% universalStairs
% speedyGallop
% speedyStairs
% massivoWalk
% massivoStairs
% centaurWalk
% centaurStairs
% miniPronk

load(taskSelection);

%% load corresponding robot parameters
% universal
% speedy
% massivo
% centaur
% mini
fprintf('getting quadruped properties \n');
quadruped = getQuadrupedProperties(robotSelection);
%% get the relative motion of the end effectors to the hips
fprintf('getting motion of end effectors relative to hip attachment points \n');
[relativeMotionHipEE, IF_hip, C_IBody] = getRelativeMotionEEHips(quat, quadruped, base, EE, dt);

%% get the liftoff and touchdown timings for each end effector
dt = t(2) - t(1);
fprintf('getting end effector liftoff and touchdown timings \n');
[tLiftoff, tTouchdown, minStepCount] = getEELiftoffTouchdownTimings(t, EE);

%% get the mean cyclic position and forces
fprintf('getting average relative motion of end effectors for one step \n');
[meanCyclicMotionHipEE, cyclicMotionHipEE, meanCyclicC_IBody, samplingStart, samplingEnd] = getHipEECyclicData(tLiftoff, tTouchdown, relativeMotionHipEE, EE, removalRatioStart, removalRatioEnd, dt, minStepCount, C_IBody);

%% get reachable positions for plot
fprintf('getting range of motion dependent on link lengths and joint limits \n');
reachablePositions = getRangeofMotion(quadruped);

%% plot data
% fprintf('plotting data \n');
% plotMotionData;

%% Inverse kinematics to calculate joint angles for each leg joint
% these q0 give x config for universalStairs
% Final term is selectFrontHind 1 = front legs, 2 = hind legs

fprintf('getting joint angles from inverse kinematics \n');

q0 = [0 -pi/4 -pi/2 0];
q.LF = inverseKinematics(meanCyclicMotionHipEE.LF.position, q0, quadruped, 1);
q.LH = inverseKinematics(meanCyclicMotionHipEE.LH.position, q0, quadruped, 2);
q.RF = inverseKinematics(meanCyclicMotionHipEE.RF.position, q0, quadruped, 1);

q0 = [0 -pi/4 -pi 0];
q.RH = inverseKinematics(meanCyclicMotionHipEE.RH.position, q0, quadruped, 2);

%% Forward kinematics to get joint positions based on angles q solved in IK
jointCount = 3; % not yet able to handle 4 joints
fprintf('getting joint positions from forward kinematics \n');
r = getJointPositions(quadruped, q, jointCount);

%% Visualize motion of single leg with rigid body model
% EESlection: 1=LF, 2=LH, 3=RF, 4=RH
fprintf('creating robot rigid body model and visualizing selected leg \n');
numberOfLoopRepetitions = 1;

EESelection = 'LF';
robot = robotSingleLegVisualization(quadruped, q, meanCyclicC_IBody, EE, meanCyclicMotionHipEE,EESelection, reachablePositions,numberOfLoopRepetitions);

EESelection = 'RF';
robot = robotSingleLegVisualization(quadruped, q, meanCyclicC_IBody, EE, meanCyclicMotionHipEE,EESelection, reachablePositions,numberOfLoopRepetitions);

EESelection = 'LH';
robot = robotSingleLegVisualization(quadruped, q, meanCyclicC_IBody, EE, meanCyclicMotionHipEE,EESelection, reachablePositions,numberOfLoopRepetitions);

EESelection = 'RH';
robot = robotSingleLegVisualization(quadruped, q, meanCyclicC_IBody, EE, meanCyclicMotionHipEE,EESelection, reachablePositions,numberOfLoopRepetitions);

  %% get joint velocities with inverse(Jacobian)* EE.velocity
  % the joint accelerations are then computed using finite difference
fprintf('getting joint velocities and accelerations \n');
joint = getJointVelocitiesUsingJacobian(meanCyclicMotionHipEE, q, quadruped, 1, dt);

%% get joint torques using inverse dynamics
% fprintf('getting joint torques from inverse dynamics \n');
% jointTorque = getInverseDynamics(joint, EE, robot);